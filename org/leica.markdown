<markdown>

Год назад, после недолгого изучения Python'а и Common Lisp'а, я взялся
за Clojure. Примерно в то же время я открыл для себя местный
файлообменный сайт, ныне опустившийся до непотребного в плане рекламы
состояния, но все еще приносящий немалую пользу, благо на нем обитает
немало народу со всего дальнего востока. На этом сайте любой желающий
может опубликовать свое сообщение — набор из картинок, текста описания
и ссылок на залитые на файлообменник файлы. Часто среди
опубликованного на сайте попадается действительно стоящий
контент. Недоразвитость приморского интернета вносит свою долю — днем
моего безлимита хватает только на веб-страницы, так что торренты
работают только ночью, местный же файлообменник работает всегда (хотя
и ложится частенько).

Ubuntu — моя домашняя система. В сообществе файлообменника есть
программирующие люди, но ориентируются они в основном на пользователей
Windows (есть на то причина — согласно статистике, процент
пользователей Linux — это процент всех пользователей). Соответственно,
под линукс программ нет (точнее, есть скрипты, но они страшны как
смертный грех), а качать ручками не мой метод.

Я взялся написать качалку. Сперва попробовал написать её на Common
Lisp'е — не получилось (я плохо его знал). Потом я попробовал написать
её на Python'е. Получилось. Но программа была многопоточная, а питон и
многопоточность — вещи не лучшим образом подходящие друг
другу. Внутренняя структура походила на многоэтажное здание,
построенное из костылей.

Я бросил Python и взялся переписать программу на Clojure. Получилось
не с первого раза, но процесс и результат меня порадовали: при всей
многопоточности работа с состоянием так же проста, как в обычных,
однопоточных императивных программах — происходит практически "не
задумываясь", одним словом Clojure — отличный выбор для многопоточных
сетевых приложений.

Далее я покажу как написать на Clojure многопоточное приложение на
примере моей качалки. Основную роль в программе будут играть агенты,
соответственно она будет "многоагентной".

# Дизайн многоагентной программы

В отличие от простых, последовательных программ, работающих в одном
потоке, сконструировать многопоточную программу куда как сложнее —
из-за большого количества потенциальных взаимодействий между её
частями. Но если следовать следующим простым правилам, задача сильно
упрощается:

1. **Неформальная спецификация.** Первым делом нужно определить — что
же программа должна делать?

2. **Компоненты.** Необходимо перечислить все формы конкурентной
активности — каждая из них становится компонентом (например,
агентом). Далее следует нарисовать блочную диаграмму системы, в
которой будут показаны все экземпляры компонентов (component
instances).

3. **Протокол сообщений.** Решить какие сообщения будут посылать
агенты и спроектировать протоколы соообщений между ними. Нарисовать
диаграмму компонентов со всеми протоколами сообщений.

4. **Диаграммы состояний.** Для каждого конкурентного компонента нужно
нарисовать диаграмму состояний и проверить, что в каждом состоянии
компонент получает и посылает правильные сообщения и выполняет
правильные действия.

5. **Закодировать. Оттестировать. Повторить.**

# Качалка

Как я уже говорил, качалки — исключительно полезные вещи. Эта не будет
исключением — она хоть и игрушечная, но достаточно полезная, чтобы я и
еще некоторые личности пользовались ею для насущных целей практически
каждый день.

## Спецификация

У нас есть несколько ссылок на страницы файлообменника, на котором
лежит несколько файлов. Файлы нужно скачать, причем их можно качать в
несколько потоков. По ходу могут возникнуть проблемы — на
файлообменнике может не оказаться файла, загрузка может оборваться, на
диске может кончиться место — при обрыве загрузка должна
возобновляться. Программа будет работать в пакетном режиме — все
требуемые для загрузки адреса, хотя нет никак проблем прикрутить к ней
интерактивный графический интерфейс.





# Переменные в Clojure

Clojure — особенный императивный язык. В отличие от подавляющего
большинства языков программирования, в которых есть только один способ
работы с состоянием — старые добрые переменные, в Clojure их как минимум
4, из-за специфичного подхода *программной транзакционной памяти*
(Software Transactional Memory, STM).

Подход к состоянию в Clojure довольно прост — он основывается на
четком разграничении **значения**, **состояния** и **идентичности**,
которые во многих языках объединены в одну сущность:

**Значение** (*value*) — нечто неизменяемое, или совокупность
неизменяемых величин (например число 3 — оно, как говорится, и в
Африке 3 — в математическом, вневременном смысле; все тройки
одинаковы, в том смысле, что существует только *одна* "тройка").

**Идентичность** (*identity*) — сущность, которую мы ассоциируем с
последовательностью значений (состояний) во времени. Даже если 2
идентичности имеют одинаковое значение (или одно и то же значение —
тут никакой разницы), они не будут равны друг другу.

**Состояние** (*value*) — значение идентичности в некоторый момент
времени.

————— картинка про идентичность значение и время

Идентичностями (т.е. изменяемыми объектами) в Clojure являются
*переменные* и *ссылки* (references), всего их 4 вида, каждая для
своих целей:

**Переменные** (*vars*) — могут изменяться только внутри одного
единственного потока, поэтому они используются как глобальные
переменные — к ним привязываются функции, константы; из-за
динамической привязки отлично подходят для разного рода
аспектно-ориентированного программирования.

**Атомы** (*atoms*) — переменные, доступные для чтения и изменения изо
всех потоков; изменяются атомарно, по-отдельности, кажлый атом в своей
транзакции. Ипользуются как старые добрые переменные в обычных языках.

**Ссылки** (*refs*) — как атомы, только изменяются внутри явно
  обозначенной программистом транзакции, поэтому используются для
  одновременного изменения сразу множества ссылок.

**Агенты** (*agents*) — переменные, доступные изо всех потоков, для
  изменения которых нужно отправить им *сообщение*, состоящее из
  функции с аргументами. После отправки сообщения агенту программа
  продолжает свою работу; изменение агента (вычисление функции
  сообщения) происходит в отдельном потоке, после чего агент принимает
  значение результата вычисления сообщения. Агенту можно послать сразу
  несколько сообщений — они сохранятся в очереди сообщений и будут
  обработаны последовательно. До тех пор, пока не будет вычислено
  сообщение, агент сохраняет свое прежнее значение.

# Агенты

Стиль программирования агентов Clojure в миру зовется *Asynchronous
Message-Passing Concurrency. Здесь *asynchronous* означает отсутствие
необходимости дожидаться изменения агента после отправки сообщения.

Агенты используются как основные "рабочие лошадки" в Clojure. В
отличие от ссылок и атомов, изменять которые можно только *чистыми*
функциями (точнее, очень рекомендуется — из-за отката и повтора
транзакций побочные эффекты могут наделать много дел) сообщения
агентов, как правило — функции с побочными эффектами.

## Отправка сообщений

Агенту можно отправить сообщение двумя способами:

    #!clojure
    (send agent function args)

— для "быстрых" или "процессороёмких", обычно без побочных эффектов,
сообщений. Такие сообщения будут выполняться на ограниченном, в
зависимости от количества ядер процессора, количестве потоков.

Другой вариант для "долгоиграющих", обычно с обильным вводом-выводом,
сообщений:

    #!clojure
    (send-off agent function args)

— такие будут выполняться на большем количестве потоков, чем сообщения
отправленные `send`'ом.

Состояние агента можно узнать в любое время — для этого не надо ждать
окончания обработки отправленного ему сообщения:

    #!clojure
    (deref agent)
    ;; или
    @agent

.............
    
## Ошибки агентов

Если во время обработки сообщения возникает ошибка (возникает
исключение, throw exception) — она сохраняется в агенте, ошибки агента
можно увидеть вызвав:

    #!clojure
    (agent-errors agent)

При этом агент становится недоступным для сообщений до тех пор, пока
не будет очищен от ошибок функцией:

    #!clojure
    (clear-agent-errors agent)

## Корректность агентов

.................



</markdown>
